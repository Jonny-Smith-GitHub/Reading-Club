#### 一、 自己提出的问题的理解：

##### 1、 提出的问题1：

​		问题一：r—PrefixSpan()与PrefixSpan最大不同点是什么？

##### 讨论后的理解：

​		每次递归调用中，或者前缀本身必须包含$i_k$ 或者映射数据库中的每个序列必须包含$i_k$ 。

#### 二、对别人的问题的理解

##### 3、 问题3：

​		P40写道PrefixSpan算法的主要优点使不生成候选序列，但在每一次对映射数据库进行匹配时，都需要遍历一次序列集，从时间复杂度问题上考虑，是不是并没有优于GSP呢？

##### 自己的理解：

​		从空间复杂度来说，深度搜索不像广度搜索一样先需要同时存储候选事务集，所需的空间较小。

##### 4、 问题4：

​		P41最后一行，经过算法计算之后得到的序列模式集合为包括{<{30}，{40}>,<{40}，{30}>}这样的序列，算不算是矛盾呢？需不需要考虑删除呢？ 

##### 自己的理解：

​		一个项在项集中最多出现一次，但是一个时间可以在序列中出现多次。  而且次序在序列中很重要，但是在项集中不重要。如{1, 2}和{2, 1}表示同一个项集，但是<i1i2><i1i2>和<i2i1><i2i1>表示不同序列。所以{<{30}，{40}>,<{40}，{30}>}是不算矛盾的，不需要删除。

#### 三、 读书计划

1、本周完成的内容章节：Web数据挖掘2.5~2.7

2、下周计划：Web数据挖掘2.8~2.9

#### 四、代码实现

```python
#参数为由（项目，最小支持度）元组组成的列表，序列集，最大支持度差别限制
def MP(IMS,T,delta):
    R=[]
    #先统计事务的数量
    sum = 0
    for t in T:
        sum += 1
    #筛选出符合最小支持度限制的项目并生成新项目集IMS2
    IMS2=[]
    R[0]=[]
    sup={}#记录支持度的字典
    for i in IMS:
        num = 0
        for l in T:
            for t in l:
                if i[0] in t:
                    num+=1
        sup[i[0]]=num
        if num/sum>i[1]:
            IMS2.append(i)
    #给新生成的频繁项目集根据MIS值以升序排序
    IMS2.sort(key=lambda x,y:x[1]<y[1])
    for it in IMS2:
        R[0].append([it[0]])
    #对于每个i in IMS2
        #找到包含他的序列字典s[i],删去不满足最小支持度限制的项目，删去非频繁项目
    s={}
    for i in IMS2:
        s[i[0]]=[]
        for l in T:
            for t in l:
                if i[0] in t:
                    cl=l
                    for ct in cl:
                        for ci in ct:
                            if (sup[ci]-sup[i[0]])/sum > delta or (sup[ci]-sup[i[0]])/sum < -delta:
                                ct.remove[ci]
                            flag = True
                            for item in IMS2:
                                if ci = item[0]:
                                    flag = False
                            if flag:
                                ct.remove[ci]
                    s[i[0]].append(cl)
        #根据上一级的R[k-2]生成R[k-1]
        #出大问题，没写完
```

